import numpy as np
from _typeshed import Incomplete
from multiprocessing.shared_memory import SharedMemory
from numpy.typing import NDArray as NDArray
from typing import Optional

class SharedMemoryArray:
    _name: Incomplete
    _shape: Incomplete
    _datatype: Incomplete
    _buffer: Incomplete
    _lock: Incomplete
    _array: Incomplete
    _is_connected: bool
    def __init__(self, name: str, shape: tuple[int, ...], datatype: np.dtype[np.int8 | np.int16 | np.int32 | np.int64 | np.uint8 | np.uint16 | np.uint32 | np.uint64 | np.float16 | np.float32 | np.float64], buffer: Optional[SharedMemory]) -> None: ...
    @classmethod
    def create_array(cls, name: str, prototype: NDArray[np.int8 | np.int16 | np.int32 | np.int64 | np.uint8 | np.uint16 | np.uint32 | np.uint64 | np.float16 | np.float32 | np.float64]) -> SharedMemoryArray: ...
    def connect(self) -> None: ...
    def disconnect(self) -> None: ...
    def read_data(self, index: int | slice) -> NDArray[np.int8 | np.int16 | np.int32 | np.int64 | np.uint8 | np.uint16 | np.uint32 | np.uint64 | np.float16 | np.float32 | np.float64]: ...
    def write_data(self, index: int | slice, data: NDArray[np.int8 | np.int16 | np.int32 | np.int64 | np.uint8 | np.uint16 | np.uint32 | np.uint64 | np.float16 | np.float32 | np.float64]) -> None: ...
    @property
    def datatype(self) -> np.dtype[np.int8 | np.int16 | np.int32 | np.int64 | np.uint8 | np.uint16 | np.uint32 | np.uint64 | np.float16 | np.float32 | np.float64]: ...
    @property
    def name(self) -> str: ...
    @property
    def shape(self) -> tuple[int, ...]: ...
    @property
    def is_connected(self) -> bool: ...
